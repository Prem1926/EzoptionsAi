sp500_symbols = [
    'MMM', 'AOS', 'ABT', 'ABBV', 'ACN', 'ADBE', 'AMD', 'AES', 'AFL', 'A', 'APD', 'ABNB', 'AKAM', 'ALB', 
    'ARE', 'ALGN', 'ALLE', 'LNT', 'ALL', 'GOOGL', 'GOOG', 'MO', 'AMZN', 'AMCR', 'AEE', 'AEP', 'AXP', 'AIG', 
    'AMT', 'AWK', 'AMP', 'AME', 'AMGN', 'APH', 'ADI', 'ANSS', 'AON', 'APA', 'APO', 'AAPL', 'AMAT', 'APTV', 
    'ACGL', 'ADM', 'ANET', 'AJG', 'AIZ', 'T', 'ATO', 'ADSK', 'ADP', 'AZO', 'AVB', 'AVY', 'AXON', 'BKR', 
    'BALL', 'BAC', 'BAX', 'BDX', 'BRK.B', 'BBY', 'TECH', 'BIIB', 'BLK', 'BX', 'BK', 'BA', 'BKNG', 'BWA', 
    'BSX', 'BMY', 'AVGO', 'BR', 'BRO', 'BF.B', 'BLDR', 'BG', 'BXP', 'CHRW', 'CDNS', 'CZR', 'CPT', 'CPB', 
    'COF', 'CAH', 'KMX', 'CCL', 'CARR', 'CAT', 'CBOE', 'CBRE', 'CDW', 'CE', 'COR', 'CNC', 'CNP', 'CF', 'CRL', 
    'SCHW', 'CHTR', 'CVX', 'CMG', 'CB', 'CHD', 'CI', 'CINF', 'CTAS', 'CSCO', 'C', 'CFG', 'CLX', 'CME', 'CMS', 
    'KO', 'CTSH', 'CL', 'CMCSA', 'CAG', 'COP', 'ED', 'STZ', 'CEG', 'COO', 'CPRT', 'GLW', 'CPAY', 'CTVA', 
    'CSGP', 'COST', 'CTRA', 'CRWD', 'CCI', 'CSX', 'CMI', 'CVS', 'DHR', 'DRI', 'DVA', 'DAY', 'DECK', 'DE', 
    'DELL', 'DAL', 'DVN', 'DXCM', 'FANG', 'DLR', 'DFS', 'DG', 'DLTR', 'D', 'DPZ', 'DOV', 'DOW', 'DHI', 'DTE', 
    'DUK', 'DD', 'EMN', 'ETN', 'EBAY', 'ECL', 'EIX', 'EW', 'EA', 'ELV', 'EMR', 'ENPH', 'ETR', 'EOG', 'EPAM', 
    'EQT', 'EFX', 'EQIX', 'EQR', 'ERIE', 'ESS', 'EL', 'EG', 'EVRG', 'ES', 'EXC', 'EXPE', 'EXPD', 'EXR', 'XOM', 
    'FFIV', 'FDS', 'FICO', 'FAST', 'FRT', 'FDX', 'FIS', 'FITB', 'FSLR', 'FE', 'FI', 'FMC', 'F', 'FTNT', 'FTV', 
    'FOXA', 'FOX', 'BEN', 'FCX', 'GRMN', 'IT', 'GE', 'GEHC', 'GEV', 'GEN', 'GNRC', 'GD', 'GIS', 'GM', 'GPC', 
    'GILD', 'GPN', 'GL', 'GDDY', 'GS', 'HAL', 'HIG', 'HAS', 'HCA', 'DOC', 'HSIC', 'HSY', 'HES', 'HPE', 'HLT', 
    'HOLX', 'HD', 'HON', 'HRL', 'HST', 'HWM', 'HPQ', 'HUBB', 'HUM', 'HBAN', 'HII', 'IBM', 'IEX', 'IDXX', 'ITW', 
    'INCY', 'IR', 'PODD', 'INTC', 'ICE', 'IFF', 'IP', 'IPG', 'INTU', 'ISRG', 'IVZ', 'INVH', 'IQV', 'IRM', 
    'JBHT', 'JBL', 'JKHY', 'J', 'JNJ', 'JCI', 'JPM', 'JNPR', 'K', 'KVUE', 'KDP', 'KEY', 'KEYS', 'KMB', 'KIM', 
    'KMI', 'KKR', 'KLAC', 'KHC', 'KR', 'LHX', 'LH', 'LRCX', 'LW', 'LVS', 'LDOS', 'LEN', 'LII', 'LLY', 'LIN', 
    'LYV', 'LKQ', 'LMT', 'L', 'LOW', 'LULU', 'LYB', 'MTB', 'MPC', 'MKTX', 'MAR', 'MMC', 'MLM', 'MAS', 'MA', 
    'MTCH', 'MKC', 'MCD', 'MCK', 'MDT', 'MRK', 'META', 'MET', 'MTD', 'MGM', 'MCHP', 'MU', 'MSFT', 'MAA', 
    'MRNA', 'MHK', 'MOH', 'TAP', 'MDLZ', 'MPWR', 'MNST', 'MCO', 'MS', 'MOS', 'MSI', 'MSCI', 'NDAQ', 'NTAP', 
    'NFLX', 'NEM', 'NWSA', 'NWS', 'NEE', 'NKE', 'NI', 'NDSN', 'NSC', 'NTRS', 'NOC', 'NCLH', 'NRG', 'NUE', 
    'NVDA', 'NVR', 'NXPI', 'ORLY', 'OXY', 'ODFL', 'OMC', 'ON', 'OKE', 'ORCL', 'OTIS', 'PCAR', 'PKG', 'PLTR', 
    'PANW', 'PARA', 'PH', 'PAYX', 'PAYC', 'PYPL', 'PNR', 'PEP', 'PFE', 'PCG', 'PM', 'PSX', 'PNW', 'PNC', 
    'POOL', 'PPG', 'PPL', 'PFG', 'PG', 'PGR', 'PLD', 'PRU', 'PEG', 'PTC', 'PSA', 'PHM', 'PWR', 'QCOM', 'DGX', 
    'RL', 'RJF', 'RTX', 'O', 'REG', 'REGN', 'RF', 'RSG', 'RMD', 'RVTY', 'ROK', 'ROL', 'ROP', 'ROST', 'RCL', 
    'SPGI', 'CRM', 'SBAC', 'SLB', 'STX', 'SRE', 'NOW', 'SHW', 'SPG', 'SWKS', 'SJM', 'SW', 'SNA', 'SOLV', 'SO', 
    'LUV', 'SWK', 'SBUX', 'STT', 'STLD', 'STE', 'SYK', 'SMCI', 'SYF', 'SNPS', 'SYY', 'TMUS', 'TROW', 'TTWO', 
    'TPR', 'TRGP', 'TGT', 'TEL', 'TDY', 'TFX', 'TER', 'TSLA', 'TXN', 'TPL', 'TXT', 'TMO', 'TJX', 'TSCO', 'TT', 
    'TDG', 'TRV', 'TRMB', 'TFC', 'TYL', 'TSN', 'USB', 'UBER', 'UDR', 'ULTA', 'UNP', 'UAL', 'UPS', 'URI', 'UNH', 
    'UHS', 'VLO', 'VTR', 'VLTO', 'VRSN', 'VRSK', 'VZ', 'VRTX', 'VTRS', 'VICI', 'V', 'VST', 'VMC', 'WRB', 'GWW', 
    'WAB', 'WBA', 'WMT', 'DIS', 'WBD', 'WM', 'WAT', 'WEC', 'WFC', 'WELL', 'WST', 'WDC', 'WY', 'WMB', 'WTW', 
    'WDAY', 'WYNN', 'XEL', 'XYL', 'YUM', 'ZBRA', 'ZBH', 'ZTS'
]

import os
from flask import Flask, request, jsonify
from flask_cors import CORS
from flask_bcrypt import Bcrypt
from flask_jwt_extended import JWTManager, create_access_token, jwt_required, get_jwt_identity
from pymongo import MongoClient
from bson import ObjectId
from datetime import datetime, timedelta
import stripe

# Existing imports from your original code
import requests
import pandas as pd
from concurrent.futures import ThreadPoolExecutor, as_completed
from datetime import date
import time
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
import threading
from cachetools import TTLCache
from typing import Dict, List
import numpy as np
from openai import OpenAI
import requests
import yfinance as yf


app = Flask(__name__)
CORS(app)

# JWT Configuration
app.config['JWT_SECRET_KEY'] = ''  # Change this to a secure random key
app.config['JWT_ACCESS_TOKEN_EXPIRES'] = timedelta(hours=2)
jwt = JWTManager(app)

# Stripe Configuration
stripe.api_key = 'STRIPE-SECRET-KEY-HERE'  # Replace with your actual Stripe secret key

bcrypt = Bcrypt(app)
# MongoDB Configuration
mongo_client = MongoClient('mongodb://localhost:27017/')
db = mongo_client['stock_gpt']
users_collection = db['users']
subscriptions_collection = db['subscriptions']
chats_collection = db['chats']
trade_alerts_collection = db['trade_alerts']
day_trades = db['day_trades']
swing_trades = db['swing_trades']
evergreen_stocks = db['evergreen_stocks']

# Configuration
API_KEY = "FINANCIAL-MODELING-PREP-KEY"
BASE_URL = "https://financialmodelingprep.com/api/v3/technical_indicator/5min"
MAX_WORKERS = 25  # Increased concurrent threads
BATCH_SIZE = 100  # Increased batch size
REQUEST_TIMEOUT = 5  # Reduced timeout

# Add this near the top where other configuration variables are defined
stripe_webhook_secret = "whsec_your_webhook_secret_here"  # Replace with your actual webhook secret

# Initialize OpenAI client
client = OpenAI(api_key="OPEN-AI-KEY-HERE")

# Cache configuration
CACHE_TIMEOUT = 300  # 5 minutes cache
stock_cache = TTLCache(maxsize=1000, ttl=CACHE_TIMEOUT)
cache_lock = threading.Lock()

# def admin_required():
#     def wrapper(fn):
#         @jwt_required()
#         def decorator(*args, **kwargs):
#             current_user_id = get_jwt_identity()
#             current_user = users_collection.find_one({"_id": ObjectId(current_user_id)})
#             if current_user and current_user.get("role") == "admin":
#                 return fn(*args, **kwargs)
#             else:
#                 return jsonify({"message": "Admin role required"}), 403
#         return decorator
#     return wrapper

# Helper function to convert MongoDB ObjectId to string
def parse_json(data):
    if isinstance(data, list):
        return [{**item, '_id': str(item['_id'])} for item in data]
    else:
        return {**data, '_id': str(data['_id'])}

# Error handling
@app.errorhandler(404)
def not_found(error):
    return jsonify({'error': 'Not found'}), 404

@app.errorhandler(500)
def server_error(error):
    return jsonify({'error': 'Server error'}), 500

class StockDataFetcher:
    def __init__(self):
        self.session = self._create_session()

    @staticmethod
    def _create_session():
        session = requests.Session()
        retry_strategy = Retry(
            total=2,
            backoff_factor=0.1,
            status_forcelist=[429, 500, 502, 503, 504]
        )
        adapter = HTTPAdapter(
            max_retries=retry_strategy,
            pool_connections=100,
            pool_maxsize=100
        )
        session.mount("http://", adapter)
        session.mount("https://", adapter)
        return session

    def fetch_data(self, symbol: str, current_date: str) -> Dict:
        cache_key = f"{symbol}_{current_date}"
        
        # Check cache first
        with cache_lock:
            if cache_key in stock_cache:
                return stock_cache[cache_key]

        try:
            # Parallel requests for RSI and EMA
            rsi_url = f"{BASE_URL}/{symbol}?type=rsi&period=14&apikey={API_KEY}&from={current_date}"
            ema_url = f"{BASE_URL}/{symbol}?type=ema&period=14&apikey={API_KEY}"
            
            rsi_future = ThreadPoolExecutor(max_workers=1).submit(
                self.session.get, rsi_url, timeout=REQUEST_TIMEOUT
            )
            ema_future = ThreadPoolExecutor(max_workers=1).submit(
                self.session.get, ema_url, timeout=REQUEST_TIMEOUT
            )
            
            rsi_response = rsi_future.result()
            ema_response = ema_future.result()
            
            if rsi_response.status_code != 200 or ema_response.status_code != 200:
                return None

            result = self._process_data(symbol, rsi_response.json(), ema_response.json())
            
            # Cache the result
            if result:
                with cache_lock:
                    stock_cache[cache_key] = result
            
            return result

        except Exception as e:
            print(f"Error fetching {symbol}: {str(e)}")
            return None

    def _process_data(self, symbol: str, rsi_data: List, ema_data: List) -> Dict:
        if not rsi_data or not ema_data:
            return None
        
        try:
            # Use numpy for faster calculations
            df = pd.DataFrame(ema_data)
            closes = df['close'].to_numpy()
            
            # Vectorized EMA calculations
            ema12 = pd.Series(closes).ewm(span=12, adjust=False).mean().to_numpy()
            ema26 = pd.Series(closes).ewm(span=26, adjust=False).mean().to_numpy()
            
            macd = ema12 - ema26
            signal_line = pd.Series(macd).ewm(span=9, adjust=False).mean().to_numpy()
            
            # Get latest values
            latest_macd = macd[-1]
            latest_signal = signal_line[-1]
            
            valid_rsi = next((i['rsi'] for i in rsi_data if i.get('rsi') is not None), None)
            
            if valid_rsi is None:
                return None
                
            if float(valid_rsi) > 70 and latest_macd < latest_signal:
                signal = "SELL"
            elif float(valid_rsi) < 30 and latest_macd > latest_signal:
                signal = "BUY"
            else:
                signal = "NEUTRAL"
                
            return {
                "stock": symbol,
                "price": rsi_data[0]['close'],
                "signal": signal
            }
            
        except Exception as e:
            print(f"Error processing {symbol}: {str(e)}")
            return None
        
def calculate_options_pl(option_data, current_option_price):
    """
    Calculate the live P/L and return percentage for options trading.
    
    Args:
        option_data (dict): Option contract information
        current_option_price (float): Current market price of the option
        
    Returns:
        dict: Results containing live P/L and return percentage
    """
    # Extract data from the option information

    print("Arsooo", option_data)

    quantity = option_data.get("qty", 0)
    initial_investment = option_data.get("amount", 0)
    if ('$' in initial_investment):
        initial_investment = float(initial_investment.replace("$", "").replace(",",""))
    else:
        initial_investment = float(initial_investment)
    ticker = option_data.get("ticker", "")
    strike_price = option_data.get("strikePrice", "")
    option_type = option_data.get("type", "")

    # current_price = float(current_stock_price)
    strike_price = strike_price
    qty = int(quantity)
    
    # Calculate live P/L
    live_pl = (current_option_price - strike_price) * qty
    # live_pl = current_value - initial_investment
    
    # Calculate return percentage
    return_percentage = (live_pl / strike_price) * 100 if strike_price != 0 else 0
    
    # Prepare results
    results = {
        "ticker": ticker,
        "strikePrice": strike_price,
        "type": option_type,
        "qty": quantity,
        "amount": f"${initial_investment:.2f}",
        "Current Option Price": f"${current_option_price:.2f}",
        "Current Value": f"${live_pl:.2f}",
        "livePL": f"${live_pl:.2f}",
        "result": "",
        "returnPercentage": f"{return_percentage:.2f}%",
        "openClosed": "Open",
        "Calculation Date": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    }
    
    return results

def stream_results():
    """Generator function to stream results"""
    current_date = str(date.today())
    fetcher = StockDataFetcher()
    
    def process_symbol(symbol):
        return fetcher.fetch_data(symbol, current_date)
    
    # Process in parallel using ThreadPoolExecutor
    with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
        futures = [executor.submit(process_symbol, symbol) 
                  for symbol in sp500_symbols]
        
        for future in as_completed(futures):
            try:
                result = future.result()
                if result:
                    yield result
            except Exception as e:
                print(f"Error processing future: {str(e)}")

# User Registration Route
@app.route('/api3/register', methods=['POST'])
def register():
    try:
        data = request.get_json()
        email = data.get('email')
        password = data.get('password')
        name = data.get('name')

        terms = f"""
        Terms and Conditions for EzoptionaAi.com
        Effective Date: {str(datetime.now().strftime("%d %b, %Y"))} 
        Last Updated: 18 Feb, 2025

        Welcome to EzoptionaAi.com ("the Platform"). These Terms and Conditions ("Terms") govern your use of the website and its services. By accessing or using EzoptionaAi.com, you agree to comply with these Terms. If you do not agree, you must discontinue use immediately.

        1. General Disclaimer
        EzoptionaAi.com provides market insights, algorithmic trading alerts, and trading-related educational content based on technical analysis, historical data, and artificial intelligence models. We do NOT provide financial, investment, or trading advice. All information is for educational and informational purposes only.

        1.1 No Investment Advice
        The Platform does not provide personalized investment, financial, legal, or tax advice.
        Any trade signals, alerts, or information provided by EzoptionaAi.com should not be interpreted as financial recommendations.
        Users should consult with a licensed financial advisor before making any investment decisions.
        1.2 No Guarantees on Profitability
        Past performance does not guarantee future results.
        Trading is inherently risky, and users acknowledge that losses are possible.
        EzoptionaAi.com does not assume responsibility for any financial gains or losses incurred by users.
        2. Trading and Risk Disclosure
        Trading in stocks, options, forex, and cryptocurrencies involves significant risk and is not suitable for everyone. You may lose all or more than your initial investment. You acknowledge and agree that:

        Market conditions fluctuate, and there is no guarantee of profit.
        You alone are responsible for your trading decisions.
        Algorithmic trading, AI-based signals, or copy trading do not remove trading risks.
        You should never invest money that you cannot afford to lose.
        3. Use of AI-Powered Alerts and Copy Trading
        EzoptionaAi.com provides AI-driven alerts, signals, and trade analysis for educational purposes only.

        No automatic trading execution – Users must manually execute trades at their own discretion.
        Copy trading feature disclaimer – Any copy trading or strategy replication is done at the user’s own risk. We do not guarantee identical results across different traders.
        4. Payments, Subscriptions, and Refund Policy
        4.1 Payment Terms
        EzoptionaAi.com offers subscription-based services that grant access to trading alerts, AI analysis, and other platform features.
        Users agree to pay all fees associated with their selected plan before accessing premium content.
        Payments are processed securely through third-party payment processors.
        4.2 No Refund Policy
        All payments are final, and there are no refunds.
        Once a user subscribes and pays for a service, they will not be eligible for a refund, regardless of dissatisfaction, performance, or trading outcomes.
        By making a payment, you acknowledge that EzoptionaAi.com does not guarantee financial gains or profitable trading results.
        4.3 Auto-Renewal & User Responsibility
        All subscriptions are automatically renewed at the end of each billing cycle unless canceled by the user.
        It is the user’s responsibility to cancel the subscription before the renewal date to avoid future charges.
        EzoptionaAi.com is not responsible for unintended renewals due to user negligence.
        4.4 Chargebacks and Disputes
        Filing a chargeback or payment dispute without a valid reason may result in account termination.
        If you have any payment-related concerns, contact [Insert Support Email] before filing a dispute.
        5. Limitation of Liability
        To the maximum extent permitted by law, EzoptionaAi.com, its owners, employees, partners, and affiliates are not liable for any direct, indirect, incidental, special, or consequential damages resulting from:

        Losses incurred from trading decisions based on platform alerts.
        System outages, technical failures, or data inaccuracies.
        Unauthorized access or security breaches.
        Market changes or unforeseen financial events.
        EzoptionaAi.com is not responsible for any losses incurred from using the information provided on the platform. You assume full responsibility for your trading activities.

        6. No Endorsement or Affiliation
        EzoptionaAi.com does not endorse any broker, exchange, or financial institution.
        The Platform is not affiliated with any financial regulatory bodies and does not require a financial services license since it does not provide financial advisory services.
        7. Account Registration and User Responsibilities
        Users must be 18 years or older to use EzoptionaAi.com.
        You are responsible for keeping your account information secure.
        Any unauthorized use of the Platform must be reported immediately.
        8. Termination of Use
        EzoptionaAi.com reserves the right to:

        Terminate accounts found to be violating our policies.
        Modify, suspend, or discontinue the platform at any time without prior notice.
        9. Governing Law and Dispute Resolution
        These Terms shall be governed by the laws of [Insert Jurisdiction]. Any disputes arising from the use of the Platform shall be resolved through arbitration or legal proceedings in [Insert Jurisdiction].

        10. Updates to These Terms
        EzoptionaAi.com may update these Terms periodically. Continued use of the Platform after updates constitutes acceptance of the revised Terms.

        11. Contact Information
        If you have any questions about these Terms, please contact us at:
        📧 info@ezoptionsai.com
        📍 [Insert Company Address]

        By using EzoptionaAi.com, you acknowledge and agree to these Terms and Conditions. If you do not accept these terms, do not use our services.
        """

        # Validate input
        if not email or not password:
            return jsonify({"success": False, "error": "Email and password are required"}), 400

        # Check if user already exists
        existing_user = users_collection.find_one({"email": email})
        if existing_user:
            return jsonify({"success": False, "error": "User already exists"}), 409

        # Hash password
        hashed_password = bcrypt.generate_password_hash(password).decode('utf-8')

        # Create user document
        user = {
            "email": email,
            "password": hashed_password,
            "name": name,
            "terms": terms,
            "created_at": datetime.utcnow(),
            "role": "user",
            "subscription": {
                "type": "free",
                "expires_at": datetime.utcnow() + timedelta(days=14)  # 14-day free trial
            }
        }

        # Insert user
        result = users_collection.insert_one(user)
        user_id = str(result.inserted_id)

        # Create access token
        access_token = create_access_token(identity=user_id)

        return jsonify({
            "success": True,
            "user_id": user_id,
            "access_token": access_token
        }), 201

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500

# User Login Route
@app.route('/api3/login', methods=['POST'])
def login():
    try:
        data = request.get_json()
        email = data.get('email')
        password = data.get('password')

        # Find user
        user = users_collection.find_one({"email": email})
        if not user:
            return jsonify({"success": False, "error": "Invalid credentials"}), 401

        # Check password
        if not bcrypt.check_password_hash(user['password'], password):
            return jsonify({"success": False, "error": "Invalid credentials"}), 401

        # Create access token
        access_token = create_access_token(identity=str(user['_id']))

        return jsonify({
            "success": True,
            "access_token": access_token,
            "user_id": str(user['_id']),
            "subscription": user.get('subscription', {"type": "free"})
        }), 200

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500
    
@app.route('/api3/validate-token', methods=['GET'])
@jwt_required()
def validate_token():
    try:
        # Get the current user's identity
        current_user_id = get_jwt_identity()
        
        # Find the user in the database
        user = users_collection.find_one({"_id": ObjectId(current_user_id)})
        
        if not user:
            return jsonify({
                "success": False, 
                "error": "User not found"
            }), 404
        
        # Return user details (excluding sensitive information)
        return jsonify({
            "success": True,
            "user": {
                "id": str(user['_id']),
                "email": user['email'],
                "name": user.get('name', ''),
                "subscription": user.get('subscription', {"type": "free"}),
                "role": user.get('role')
            }
        }), 200
    
    except Exception as e:
        print(f"Token validation error: {str(e)}")
        return jsonify({
            "success": False, 
            "error": "Token validation failed"
        }), 500

@app.route('/api3/create-checkout-session', methods=['POST'])
@jwt_required()
def create_checkout_session():
    try:
        # Get current user
        user_id = get_jwt_identity()
        data = request.get_json()
        price_id = data.get('priceId')
        
        if not price_id:
            return jsonify({
                "success": False, 
                "error": "Price ID is required"
            }), 400
        
        # Logging for debugging
        print(f"Creating checkout session for user: {user_id}, price: {price_id}")
        
        try:
            # Create Stripe Checkout Session with the provided price ID
            checkout_session = stripe.checkout.Session.create(
                payment_method_types=['card'],
                line_items=[{
                    'price': price_id,
                    'quantity': 1,
                }],
                mode='subscription',
                success_url='https://ezoptionsai.com/subscription/success?session_id={CHECKOUT_SESSION_ID}',
                cancel_url='https://ezoptionsai.com/subscription/cancel',
                client_reference_id=user_id
            )

            print(f"Checkout session created: {checkout_session.url}")

            return jsonify({
                "success": True, 
                "checkout_url": checkout_session.url
            })

        except stripe.error.StripeError as stripe_error:
            print(f"Stripe Error: {str(stripe_error)}")
            return jsonify({
                "success": False, 
                "error": f"Stripe Error: {str(stripe_error)}"
            }), 400

    except Exception as e:
        print(f"Unexpected error in checkout session: {str(e)}")
        return jsonify({
            "success": False, 
            "error": f"Unexpected error: {str(e)}"
        }), 500

# Updated Webhook Route - consolidate both webhook handlers into one
@app.route('/api3/stripe-webhook', methods=['POST'])
def stripe_webhook():
    try:
        payload = request.get_data(as_text=True)
        sig_header = request.headers.get('Stripe-Signature')

        try:
            event = stripe.Webhook.construct_event(
                payload, sig_header, stripe_webhook_secret
            )
        except ValueError as e:
            # Invalid payload
            return jsonify({"success": False, "error": str(e)}), 400
        except stripe.error.SignatureVerificationError as e:
            # Invalid signature
            return jsonify({"success": False, "error": str(e)}), 400

        # Handle the checkout.session.completed event
        if event['type'] == 'checkout.session.completed':
            session = event['data']['object']
            
            # Get the client_reference_id to identify the user
            user_id = session.get('client_reference_id')
            subscription_id = session.get('subscription')
            customer_id = session.get('customer')
            
            if user_id and subscription_id:
                # Update user's subscription status in your database
                try:
                    # Get subscription details from Stripe
                    subscription = stripe.Subscription.retrieve(subscription_id)
                    
                    # Get the plan details
                    plan_id = subscription['items']['data'][0]['price']['id']
                    
                    # Always set subscription_type to "pro" for any new subscription
                    subscription_type = "pro"
                    
                    # Only override to premium if explicitly in the plan ID
                    if "premium" in plan_id.lower():
                        subscription_type = "premium"
                    
                    # Calculate expiration based on billing cycle
                    if subscription['items']['data'][0]['price']['recurring']['interval'] == 'year':
                        expires_at = datetime.utcnow() + timedelta(days=365)
                    else:  # Assume month
                        expires_at = datetime.utcnow() + timedelta(days=30)
                    
                    # Update user in MongoDB
                    users_collection.update_one(
                        {"_id": ObjectId(user_id)},
                        {"$set": {
                            "subscription": {
                                "type": subscription_type,
                                "stripe_customer_id": customer_id,
                                "stripe_subscription_id": subscription_id,
                                "plan_id": plan_id,
                                "status": subscription['status'],
                                "expires_at": expires_at
                            }
                        }}
                    )
                    
                    # Also store subscription in separate collection for reference
                    subscriptions_collection.insert_one({
                        "user_id": ObjectId(user_id),
                        "stripe_subscription_id": subscription_id,
                        "stripe_customer_id": customer_id,
                        "plan_id": plan_id,
                        "status": subscription['status'],
                        "type": subscription_type,  # Store the subscription type here too
                        "created_at": datetime.utcnow(),
                        "expires_at": expires_at,
                        "raw_data": subscription  # Store the raw subscription data for reference
                    })
                    
                except Exception as e:
                    print(f"Error updating user subscription: {str(e)}")
                    return jsonify({"success": False, "error": str(e)}), 500
        
        # Handle subscription updated events
        elif event['type'] == 'customer.subscription.updated':
            subscription = event['data']['object']
            subscription_id = subscription['id']
            
            # Find user with this subscription ID
            user = users_collection.find_one({"subscription.stripe_subscription_id": subscription_id})
            
            if user:
                # Get the plan details
                plan_id = subscription['items']['data'][0]['price']['id']
                
                # Always maintain pro status unless explicitly premium
                subscription_type = "pro"
                if "premium" in plan_id.lower():
                    subscription_type = "premium"
                
                # Update expiration based on billing cycle
                if subscription['items']['data'][0]['price']['recurring']['interval'] == 'year':
                    expires_at = datetime.utcnow() + timedelta(days=365)
                else:  # Assume month
                    expires_at = datetime.utcnow() + timedelta(days=30)
                
                # Update user subscription
                users_collection.update_one(
                    {"_id": user['_id']},
                    {"$set": {
                        "subscription.status": subscription['status'],
                        "subscription.type": subscription_type,
                        "subscription.plan_id": plan_id,
                        "subscription.expires_at": expires_at
                    }}
                )
                
                # Update subscription document
                subscriptions_collection.update_one(
                    {"stripe_subscription_id": subscription_id},
                    {"$set": {
                        "status": subscription['status'],
                        "type": subscription_type,
                        "plan_id": plan_id,
                        "expires_at": expires_at,
                        "updated_at": datetime.utcnow(),
                        "raw_data": subscription
                    }}
                )
        
        # Handle subscription deleted (canceled) events
        elif event['type'] == 'customer.subscription.deleted':
            subscription = event['data']['object']
            subscription_id = subscription['id']
            
            # Find user with this subscription ID
            user = users_collection.find_one({"subscription.stripe_subscription_id": subscription_id})
            
            if user:
                # Update user subscription to free
                users_collection.update_one(
                    {"_id": user['_id']},
                    {"$set": {
                        "subscription": {
                            "type": "free",
                            "status": "canceled",
                            "expires_at": datetime.utcnow()  # Expire immediately
                        }
                    }}
                )
                
                # Update subscription document
                subscriptions_collection.update_one(
                    {"stripe_subscription_id": subscription_id},
                    {"$set": {
                        "status": "canceled",
                        "type": "free",
                        "updated_at": datetime.utcnow(),
                        "raw_data": subscription
                    }}
                )

        return jsonify({"success": True}), 200

    except Exception as e:
        print(f"Error in webhook: {str(e)}")
        return jsonify({"success": False, "error": str(e)}), 500

# Add a subscription status endpoint that works with MongoDB
@app.route('/api3/subscription-status', methods=['GET'])
@jwt_required()
def get_subscription_status():
    user_id = get_jwt_identity()
    
    try:
        # Find user in MongoDB
        user = users_collection.find_one({"_id": ObjectId(user_id)})
        
        if not user:
            return jsonify({
                "success": False,
                "error": "User not found"
            }), 404
        
        # Check if user has subscription data
        subscription_data = user.get('subscription', {})
        
        # If user has an active subscription with a Stripe subscription ID
        if (subscription_data.get('type') in ['pro', 'premium'] and 
            subscription_data.get('stripe_subscription_id') and 
            subscription_data.get('status') == 'active'):
            
            # Get latest subscription details from Stripe
            try:
                subscription = stripe.Subscription.retrieve(subscription_data['stripe_subscription_id'])
                
                # Ensure subscription type is correct
                subscription_type = subscription_data.get('type', 'pro')
                
                # Format the response
                return jsonify({
                    "success": True,
                    "hasActiveSubscription": True,
                    "subscription": {
                        "id": subscription['id'],
                        "status": subscription['status'],
                        "currentPeriodEnd": subscription['current_period_end'],
                        "plan": {
                            "id": subscription['items']['data'][0]['price']['id'],
                            "interval": subscription['items']['data'][0]['price']['recurring']['interval'],
                            "amount": subscription['items']['data'][0]['price']['unit_amount'] / 100,
                            "type": subscription_type
                        }
                    }
                })
            except stripe.error.StripeError as e:
                print(f"Stripe error retrieving subscription: {str(e)}")
                # Return local data if Stripe API fails
                return jsonify({
                    "success": True,
                    "hasActiveSubscription": True,
                    "subscription": {
                        "id": subscription_data.get('stripe_subscription_id'),
                        "status": subscription_data.get('status'),
                        "type": subscription_data.get('type', 'pro'),
                        "expiresAt": subscription_data.get('expires_at')
                    },
                    "note": "Using cached data due to Stripe API error"
                })
        else:
            # User has no active subscription
            is_trial = False
            if (subscription_data.get('type') == 'free' and 
                subscription_data.get('expires_at') and 
                subscription_data.get('expires_at') > datetime.utcnow()):
                is_trial = True
                
            return jsonify({
                "success": True,
                "hasActiveSubscription": False,
                "isTrial": is_trial,
                "trialEndsAt": subscription_data.get('expires_at') if is_trial else None
            })
            
    except Exception as e:
        print(f"Error getting subscription status: {str(e)}")
        return jsonify({
            "success": False,
            "error": f"Error retrieving subscription status: {str(e)}"
        }), 500

@app.route('/api3/rsi', methods=['GET'])
def get_stock_signals():
    try:
        start_time = time.time()
        results = []
        
        for result in stream_results():
            results.append(result)
        
        execution_time = time.time() - start_time
        print(f"Total execution time: {execution_time:.2f} seconds")
        
        return jsonify({'message': results}), 200
        
    except Exception as e:
        print(f"Error in main route: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/api3/graph', methods=['POST'])
def show_graph():
    try:
        data = request.get_json()
        current_date = date.today()
        symbol = data['symbol']
        rsi_url = f"{BASE_URL}/{symbol}?type=rsi&period=14&apikey={API_KEY}&from={current_date}"
        ans = requests.get(rsi_url)
        resp = ans.json()
        return jsonify({'message': resp}), 200
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api3/chat', methods=['POST'])
def corporate_gpt():
    try:
        data = request.get_json()
        query = data.get('query', '')
        chat_history = data.get('chat_history', '')
        chat_id = data.get('chat_id', '')
        
        # Construct prompt
        prompt = """
        You are a professional Financial Analyst. You will be guiding user queries related to investments, stock market and Finances. You will be guiding them about investment and stocks.
        """
        messages = []
        messages.append({"role": "system", "content": prompt})
        
        if len(chat_history) > 0:
            for chat in chat_history:
                messages.append(chat)
        
        # Add the current user message to messages
        current_user_message = {"role": "user", "content": query}
        messages.append(current_user_message)
        
        # Create chat completion
        response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=messages
        )
        
        assistant_message = {"role": "assistant", "content": response.choices[0].message.content}
        
        # Save or update chat in MongoDB
        if not chat_id:
            # Create new chat
            chat_document = {
                'title': query,  # First user message becomes the title
                'messages': [
                    current_user_message,  # Add the current user message
                    assistant_message      # Add the assistant's response
                ],
                'created_at': datetime.utcnow(),
                'updated_at': datetime.utcnow()
            }
            result = chats_collection.insert_one(chat_document)
            chat_id = str(result.inserted_id)
        else:
            # Update existing chat
            chats_collection.update_one(
                {'_id': ObjectId(chat_id)},
                {
                    '$push': {
                        'messages': {
                            '$each': [current_user_message, assistant_message]
                        }
                    },
                    '$set': {'updated_at': datetime.utcnow()}
                }
            )
        
        return jsonify({
            "success": True,
            "recommendation": assistant_message["content"],
            "chat_id": chat_id
        })
    
    except Exception as e:
        print(e)
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500


@app.route('/api3/chats', methods=['GET'])
def get_chats():
    try:
        chats = list(chats_collection.find().sort('updated_at', -1))
        # Convert ObjectId to string for JSON serialization
        for chat in chats:
            chat['_id'] = str(chat['_id'])
        return jsonify({
            "success": True,
            "chats": chats
        })
    except Exception as e:
        print(e)
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/api3/chat/<chat_id>', methods=['GET'])
def get_chat(chat_id):
    try:
        chat = chats_collection.find_one({'_id': ObjectId(chat_id)})
        if chat:
            chat['_id'] = str(chat['_id'])
            return jsonify({
                "success": True,
                "chat": chat
            })
        return jsonify({
            "success": False,
            "error": "Chat not found"
        }), 404
    except Exception as e:
        print(e)
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/api3/chat/<chat_id>', methods=['DELETE'])
def delete_chat(chat_id):
    try:
        result = chats_collection.delete_one({'_id': ObjectId(chat_id)})
        if result.deleted_count > 0:
            return jsonify({
                "success": True,
                "message": "Chat deleted successfully"
            })
        return jsonify({
            "success": False,
            "error": "Chat not found"
        }), 404
    except Exception as e:
        print(e)
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500
    
@app.route('/api3/trade_alerts', methods=['GET'])
def show_trade_alert():
    trades = trade_alerts_collection.find()
    
    # Convert MongoDB cursor to a list of dictionaries, ensuring `_id` is a string
    trade_list = [
        {**trade, "_id": str(trade["_id"])} for trade in trades
    ]
    
    return jsonify({'data': trade_list}), 200

@app.route('/api3/trade_alerts', methods=['POST'])
def add_trade_alert():
    # current_user_id = get_jwt_identity()
    
    # current_user = users_collection.find_one({"_id": ObjectId(current_user_id)})

    # print(current_user_id)

    # if current_user.get("role") != "admin":
    #     return jsonify({'error': 'Only Admins allowed'}), 403

    data = request.get_json()
    if not data:
        return jsonify({'error': 'Invalid data'}), 400

    required_fields = ['ticker', 'strike_price', 'type', 'expiry', 'quantity', 'amount', 'executed_time']
    if not all(field in data for field in required_fields):
        return jsonify({'error': 'Missing required fields'}), 400

    trade_alert_id = trade_alerts_collection.insert_one(data).inserted_id
    return jsonify({'message': 'Trade alert added successfully', 'id': str(trade_alert_id)}), 201


@app.route('/api3/trade_alerts/<trade_alert_id>', methods=["PUT"])
def update_trade_alert(trade_alert_id):
    # current_user_id = get_jwt_identity()
    
    # current_user = users_collection.find_one({"_id": ObjectId(current_user_id)})
    
    # if current_user.get("role") != "admin":
    #     return jsonify({'error': 'Only Admins allowed'}), 403

    data = request.get_json()
    if not data:
        return jsonify({'error': 'Invalid data'}), 400

    result = trade_alerts_collection.update_one({'_id': ObjectId(trade_alert_id)}, {'$set': data})
    if result.modified_count > 0:
        return jsonify({'message': 'Trade alert updated successfully'}), 200
    else:
        return jsonify({'error': 'Trade alert not found'}), 404


@app.route('/api3/trade_alerts/<id>', methods=['DELETE'])
def delete_trade_alert(id):
    # current_user_id = get_jwt_identity()
    
    # current_user = users_collection.find_one({"_id": ObjectId(current_user_id)})

    # print(current_user_id)
    
    # if current_user.get("role") != "admin":
    #     return jsonify({'error': 'Only Admins allowed'}), 403
    
    result = trade_alerts_collection.delete_one({'_id': ObjectId(id)})
    if result.deleted_count > 0:
        return jsonify({'message': 'Trade alert deleted successfully'}), 200
    else:
        return jsonify({'error': 'Trade alert not found'}), 404
    

# @app.route('/api3/day-trades', methods=['GET'])
# def get_day_trades():
#     try:
#         # Optional query parameters
#         ticker = request.args.get('ticker')
        
#         query = {}
#         if ticker:
#             query['ticker'] = {'$regex': ticker, '$options': 'i'}
            
#         trades_list = list(day_trades.find(query))

#         print("Trades List", float(trades_list[0]['amount'][1:]))

#         return jsonify(parse_json(trades_list))
#     except Exception as e:
#         return jsonify({'error': str(e)}), 500

# @app.route('/api3/day-trades', methods=['GET'])
# def get_day_trades():
#     try:
#         query = {}

#         trades_list = list(day_trades.find(query))

#         result = []
#         for trade in trades_list[:5]:
#             live_pl = "--"
#             return_percentage = "--"
#             result_status = trade.get('result', '--') # Initialize result status
#             try:
#                 ticker = yf.Ticker(trade['ticker'])
#                 current_stock_price = ticker.info['regularMarketPrice']

#                 current_price = float(current_stock_price)
#                 strike_price = float(trade['strikePrice'].replace("$", "").replace(",",""))
#                 premium = float(trade['amount'].replace("$", "").replace(",",""))
#                 qty = trade['qty']

#                 if trade['type'] == 'Call' and trade['longShort'] == 'Long':
#                     live_pl = (current_price - strike_price - premium) * qty * 100
#                 elif trade['type'] == 'Put' and trade['longShort'] == 'Long':
#                     live_pl = (strike_price - current_price - premium) * qty * 100
#                 elif trade['type'] == 'Call' and trade['longShort'] == 'Short':
#                     if current_price <= strike_price:
#                         live_pl = premium * qty * 100
#                     else:
#                         live_pl = (premium - (current_price - strike_price)) * qty * 100
#                 elif trade['type'] == 'Put' and trade['longShort'] == 'Short':
#                     if current_price >= strike_price:
#                         live_pl = premium * qty * 100
#                     else:
#                         live_pl = (premium - (strike_price - current_price)) * qty * 100
#                 else:
#                   live_pl = (premium - (current_price - strike_price)) * qty * 100

#                 trade['livePL'] = str(float("{:.2f}".format(live_pl)))

#                 # Calculate return percentage
#                 initial_investment = premium * qty * 100
#                 if initial_investment != 0:
#                     return_percentage = (live_pl / initial_investment) * 100
#                     return_percentage = f"{'+' if return_percentage >= 0 else ''}{return_percentage:.2f}%"
#                 else:
#                     return_percentage = "N/A"

#                 trade['returnPercentage'] = return_percentage

#                 # Determine Profit/Loss if closed
#                 if trade.get('openClosed') == 'Closed':
#                     if live_pl > 0:
#                         result_status = 'Profit'
#                     elif live_pl < 0:
#                         result_status = 'Loss'
#                     else:
#                         result_status = 'Break Even'

#                 trade['result'] = result_status

#             except (ValueError, KeyError, ZeroDivisionError):
#                 trade['livePL'] = "Invalid Price"
#                 trade['returnPercentage'] = "N/A"
#                 trade['result'] = '--' #reset result if error occurs

#             result.append(trade)

#         return jsonify(parse_json(result))
#     except Exception as e:
#         return jsonify({'error': str(e)}), 500

@app.route('/api3/day-trades', methods=['GET'])
def get_day_trades():
    try:
        query = {"openClosed": "Open"}

        trades_list = list(day_trades.find(query))

        result = []

        kaki = {}

        for trade in trades_list:
            live_pl = "--"
            return_percentage = "--"
            # result_status = trade.get('result', '--') # Initialize result status
            try:
                ticker = yf.Ticker(trade['ticker'])
                current_stock_price = ticker.info['regularMarketPrice']

                # current_price = float(current_stock_price)
                # strike_price = float(trade['strikePrice'].replace("$", "").replace(",",""))
                # premium = float(trade['amount'].replace("$", "").replace(",",""))
                # qty = trade['qty']

                kaki = calculate_options_pl(trade, current_stock_price)

                kaki['_id'] = str(trade['_id'])

                print("Kaki", kaki)

            except (ValueError, KeyError, ZeroDivisionError):
                trade['livePL'] = "Invalid Price"
                trade['returnPercentage'] = "N/A"
                trade['result'] = '--' #reset result if error occurs

            result.append(kaki)

        print("Reusltwa", result)

        return jsonify(parse_json(result))
    except Exception as e:
        return jsonify({'error': str(e)}), 500


@app.route('/api3/day-trades', methods=['POST'])
def create_day_trade():
    try:
        data = request.get_json()
        required_fields = ['ticker', 'strikePrice', 'type', 'expiry', 'qty', 'amount', 'executed']
        
        for field in required_fields:
            if field not in data:
                return jsonify({'error': f'Missing required field: {field}'}), 400
                
        # Add default values
        data['created_at'] = datetime.now()
        if 'livePL' not in data:
            data['livePL'] = data['amount']  # Default to the entry amount
            data['returnPercentage'] = '0.00%'
        
        trade_id = day_trades.insert_one(data).inserted_id
        return jsonify({'success': True, 'trade_id': str(trade_id)})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api3/day-trades/<trade_id>', methods=['GET'])
def get_day_trade(trade_id):
    try:
        trade = day_trades.find_one({'_id': ObjectId(trade_id)})
        if not trade:
            return jsonify({'error': 'Trade not found'}), 404
        return jsonify(parse_json(trade))
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api3/day-trades/<trade_id>', methods=['PUT'])
def update_day_trade(trade_id):
    try:
        data = request.get_json()
        data['updated_at'] = datetime.now()

        print("DAta", data)

        data.pop('_id', None)
        
        # Calculate return percentage if both livePL and amount are provided
        if 'livePL' in data and 'amount' in data:
            live_pl = float(data['livePL'].replace('$', ''))
            amount = float(data['amount'].replace('$', ''))
            percentage = ((live_pl - amount) / amount) * 100
            data['returnPercentage'] = f"{'+' if percentage >= 0 else ''}{percentage:.2f}%"
        
        # If closing time is provided, set the result
        if 'closing' in data and data['closing'] != '--':
            live_pl = float(data.get('livePL', '0').replace('$', ''))
            amount = float(data.get('amount', '0').replace('$', ''))
            data['result'] = 'Profit' if live_pl > amount else 'Loss'
            
        result = day_trades.update_one(
            {'_id': ObjectId(trade_id)},
            {'$set': data}
        )
        
        if result.matched_count == 0:
            return jsonify({'error': 'Trade not found'}), 404
            
        return jsonify({'success': True, 'updated': result.modified_count > 0})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api3/day-trades/<trade_id>', methods=['DELETE'])
def delete_day_trade(trade_id):
    try:
        result = day_trades.delete_one({'_id': ObjectId(trade_id)})
        if result.deleted_count == 0:
            return jsonify({'error': 'Trade not found'}), 404
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

# -------------- Swing Trading APIs ---------------

@app.route('/api3/swing-trades', methods=['GET'])
def get_swing_trades():
    try:
        query = {"openClosed": "Open"}

        trades_list = list(swing_trades.find(query))

        result = []

        kaki = {}

        for trade in trades_list:
            live_pl = "--"
            return_percentage = "--"
            # result_status = trade.get('result', '--') # Initialize result status
            try:
                ticker = yf.Ticker(trade['ticker'])
                current_stock_price = ticker.info['regularMarketPrice']

                # current_price = float(current_stock_price)
                # strike_price = float(trade['strikePrice'].replace("$", "").replace(",",""))
                # premium = float(trade['amount'].replace("$", "").replace(",",""))
                # qty = trade['qty']

                kaki = calculate_options_pl(trade, current_stock_price)

                kaki['_id'] = str(trade['_id'])

                print("Kaki", kaki)

            except (ValueError, KeyError, ZeroDivisionError):
                trade['livePL'] = "Invalid Price"
                trade['returnPercentage'] = "N/A"
                trade['result'] = '--' #reset result if error occurs

            result.append(kaki)

        print("Reusltwa", result)

        return jsonify(parse_json(result))
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api3/swing-trades', methods=['POST'])
def create_swing_trade():
    try:
        data = request.get_json()
        required_fields = ['ticker', 'strikePrice', 'type', 'expiry', 'qty', 'amount', 'executed']
        
        for field in required_fields:
            if field not in data:
                return jsonify({'error': f'Missing required field: {field}'}), 400
                
        # Add default values
        data['created_at'] = datetime.now()
        if 'status' not in data:
            data['status'] = 'ACTIVE'
        if 'livePL' not in data:
            data['livePL'] = data['amount']  # Default to the entry amount
            data['returnPercentage'] = '0.00%'
        
        trade_id = swing_trades.insert_one(data).inserted_id
        return jsonify({'success': True, 'trade_id': str(trade_id)})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api3/swing-trades/<trade_id>', methods=['GET'])
def get_swing_trade(trade_id):
    try:
        trade = swing_trades.find_one({'_id': ObjectId(trade_id)})
        if not trade:
            return jsonify({'error': 'Trade not found'}), 404
        return jsonify(parse_json(trade))
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api3/swing-trades/<trade_id>', methods=['PUT'])
def update_swing_trade(trade_id):
    try:
        data = request.get_json()
        data['updated_at'] = datetime.now()

        data.pop('_id', None)
        
        # Calculate return percentage if both livePL and amount are provided
        if 'livePL' in data and 'amount' in data:
            live_pl = float(data['livePL'].replace('$', ''))
            amount = float(data['amount'].replace('$', ''))
            percentage = ((live_pl - amount) / amount) * 100
            data['returnPercentage'] = f"{'+' if percentage >= 0 else ''}{percentage:.2f}%"
        
        # If closing date is provided, set the result and status
        if 'closing' in data and data['closing'] != '--':
            live_pl = float(data.get('livePL', '0').replace('$', ''))
            amount = float(data.get('amount', '0').replace('$', ''))
            data['result'] = 'Profit' if live_pl > amount else 'Loss'
            data['status'] = 'CLOSED'
            
        result = swing_trades.update_one(
            {'_id': ObjectId(trade_id)},
            {'$set': data}
        )
        
        if result.matched_count == 0:
            return jsonify({'error': 'Trade not found'}), 404
            
        return jsonify({'success': True, 'updated': result.modified_count > 0})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api3/swing-trades/<trade_id>', methods=['DELETE'])
def delete_swing_trade(trade_id):
    try:
        result = swing_trades.delete_one({'_id': ObjectId(trade_id)})
        if result.deleted_count == 0:
            return jsonify({'error': 'Trade not found'}), 404
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

# -------------- Evergreen Stocks APIs ---------------

@app.route('/api3/evergreen-stocks', methods=['GET'])
def get_evergreen_stocks():
    try:
        # Optional query parameters
        search = request.args.get('search')
        sort_key = request.args.get('sort_key', 'ticker')
        sort_direction = request.args.get('sort_direction', 'ascending')
        
        query = {}
        if search:
            query['$or'] = [
                {'ticker': {'$regex': search, '$options': 'i'}},
                {'name': {'$regex': search, '$options': 'i'}}
            ]
            
        # Prepare sort parameters
        sort_dir = 1 if sort_direction == 'ascending' else -1
        
        stocks_list = list(evergreen_stocks.find(query).sort(sort_key, sort_dir))
        return jsonify(parse_json(stocks_list))
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api3/evergreen-stocks', methods=['POST'])
def create_evergreen_stock():
    try:
        data = request.get_json()
        required_fields = ['ticker', 'name', 'sector', 'price', 'marketCap']
        
        for field in required_fields:
            if field not in data:
                return jsonify({'error': f'Missing required field: {field}'}), 400
                
        # Add default values
        data['created_at'] = datetime.now()
        if 'change' not in data:
            data['change'] = '0.00%'
        
        stock_id = evergreen_stocks.insert_one(data).inserted_id
        return jsonify({'success': True, 'stock_id': str(stock_id)})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api3/evergreen-stocks/<stock_id>', methods=['GET'])
def get_evergreen_stock(stock_id):
    try:
        stock = evergreen_stocks.find_one({'_id': ObjectId(stock_id)})
        if not stock:
            return jsonify({'error': 'Stock not found'}), 404
        return jsonify(parse_json(stock))
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api3/evergreen-stocks/<stock_id>', methods=['PUT'])
def update_evergreen_stock(stock_id):
    try:
        data = request.get_json()
        data['updated_at'] = datetime.now()
        
        result = evergreen_stocks.update_one(
            {'_id': ObjectId(stock_id)},
            {'$set': data}
        )
        
        if result.matched_count == 0:
            return jsonify({'error': 'Stock not found'}), 404
            
        return jsonify({'success': True, 'updated': result.modified_count > 0})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api3/evergreen-stocks/<stock_id>', methods=['DELETE'])
def delete_evergreen_stock(stock_id):
    try:
        result = evergreen_stocks.delete_one({'_id': ObjectId(stock_id)})
        if result.deleted_count == 0:
            return jsonify({'error': 'Stock not found'}), 404
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

# -------------- Analytics APIs (can be expanded) ---------------

@app.route('/api3/analytics/sector-distribution', methods=['GET'])
def sector_distribution():
    try:
        pipeline = [
            {"$group": {"_id": "$sector", "count": {"$sum": 1}}},
            {"$sort": {"count": -1}}
        ]
        
        result = list(evergreen_stocks.aggregate(pipeline))
        return jsonify(result)
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api3/analytics/dividend-yield', methods=['GET'])
def dividend_yield_comparison():
    try:
        # Find top stocks by dividend yield
        pipeline = [
            {"$match": {"divYield": {"$exists": True, "$ne": ""}}},
            {"$project": {
                "ticker": 1,
                "name": 1,
                "divYield": 1,
                "divYieldValue": {
                    "$convert": {
                        "input": {"$substr": ["$divYield", 0, {"$subtract": [{"$strLenCP": "$divYield"}, 1]}]},
                        "to": "double",
                        "onError": 0
                    }
                }
            }},
            {"$sort": {"divYieldValue": -1}},
            {"$limit": 10}
        ]
        
        result = list(evergreen_stocks.aggregate(pipeline))
        return jsonify(parse_json(result))
    except Exception as e:
        return jsonify({'error': str(e)}), 500
    
@app.route('/api3/fear-greed-index')
def fear_greed_index():
    try:
        url = "https://fear-and-greed-index.p.rapidapi.com/v1/fgi"

        headers = {
            "x-rapidapi-key": "RAPID-API-KEY-HERE",
            "x-rapidapi-host": "fear-and-greed-index.p.rapidapi.com"
        }

        response = requests.get(url, headers=headers)

        return jsonify({'data': response.json()}), 200
    except Exception as e:
        return jsonify({'error': e}), 500
    

@app.route('/api3/news')
def financial_news():
    try:
        url = "https://api.polygon.io/v2/reference/news?apiKey=Xn2JvDXzc4HpW2hTjhevO9p8Q_SJ6VDN"

        response = requests.get(url)

        return jsonify({'data': response.json()}), 200
    except Exception as e:
        return jsonify({'error': e}), 500
    

if __name__ == '__main__':
    app.run(debug=True, threaded=True, host='0.0.0.0', port=6700)
